using Microsoft.Xna.Framework.Graphics;
using System;
using System.Diagnostics;
using System.IO;

namespace Noesis.MonoGame.CodeGenerator
{
    public class VertexSourceGenerator
    {
        public void Execute(string outputPath)
        {
            foreach (Shader.Vertex.Format.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Enum)))
            {
                if (item == Shader.Vertex.Format.Enum.Count)
                    continue;

                string vertexTypeName = $"NoesisVertex{item}";

                string source = $@"// <auto-generated/>
using System;
using System.Diagnostics;
﻿using System.Runtime.InteropServices;

namespace Noesis.MonoGame.Generated
{{
    [StructLayout(LayoutKind.Sequential, Pack = 2)]
    public struct {vertexTypeName} : {typeof(Microsoft.Xna.Framework.Graphics.IVertexType).FullName!}
    {{
        private static readonly {typeof(Microsoft.Xna.Framework.Graphics.VertexDeclaration).FullName!} _vertexDeclaration;
        {typeof(Microsoft.Xna.Framework.Graphics.VertexDeclaration).FullName!}  {typeof(Microsoft.Xna.Framework.Graphics.IVertexType).FullName!}.VertexDeclaration => _vertexDeclaration;        

{GetFields(item.ToString())}
        static {vertexTypeName}()
		{{
			{typeof(Microsoft.Xna.Framework.Graphics.VertexElement).FullName!}[] elements = new {typeof(Microsoft.Xna.Framework.Graphics.VertexElement).FullName!}[] 
            {{ 
{GetVertexElements(item)}
            }};			
			_vertexDeclaration = new {typeof(Microsoft.Xna.Framework.Graphics.VertexDeclaration).FullName!}(elements);

            Debug.Assert(_vertexDeclaration.VertexStride == Marshal.SizeOf<{vertexTypeName}>());
		}}
    }}
}}
";

                File.WriteAllText(System.IO.Path.Combine(outputPath, $"{vertexTypeName}.generated.cs"), source);
            }

            GenerateVertexUtils(outputPath);
        }

        private string GetFields(string vertexTypeName)
        {
            string result = string.Empty;

            foreach (Shader.Vertex.Format.Attr.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Attr.Enum)))
            {
                if (vertexTypeName.Contains(item.ToString()))
                {
                    result += $"\t\tpublic {GetVertexElementMonogameFormat(ShaderTypeForAttr(item))} {item};\r\n";
                }
            }

            return result;
        }

        private static string GetVertexElementMonogameFormat(Shader.Vertex.Format.Attr.Type.Enum attributeType)
        {
            switch (attributeType)
            {
                case Shader.Vertex.Format.Attr.Type.Enum.Float:
                    return typeof(float).FullName!;

                case Shader.Vertex.Format.Attr.Type.Enum.Float2:
                    return typeof(Microsoft.Xna.Framework.Vector2).FullName!;

                case Shader.Vertex.Format.Attr.Type.Enum.Float4:
                    return typeof(Microsoft.Xna.Framework.Vector4).FullName!;

                case Shader.Vertex.Format.Attr.Type.Enum.UShort4Norm:
                    return typeof(Microsoft.Xna.Framework.Graphics.PackedVector.NormalizedShort4).FullName!;                    

                case Shader.Vertex.Format.Attr.Type.Enum.UByte4Norm:
                    return typeof(Microsoft.Xna.Framework.Color).FullName!;
            }

            return "Unknown";
        }

        private string GetVertexElements(Shader.Vertex.Format.Enum vertexFormat)
        {
            string result = string.Empty;
            int offset = 0;

            foreach (Shader.Vertex.Format.Attr.Enum item in Enum.GetValues(typeof(Shader.Vertex.Format.Attr.Enum)))
            {
                if (vertexFormat.ToString().Contains(item.ToString()))
                {
                    result += $"\t\t\t\tnew ({offset}, " +
                        $"{typeof(Microsoft.Xna.Framework.Graphics.VertexElementFormat).FullName!}.{GetVertexElementFormat(ShaderTypeForAttr(item))}, " +
                        $"{typeof(Microsoft.Xna.Framework.Graphics.VertexElementUsage).FullName!}.{GetVertexElementUsage(item)}),\r\n";
                    offset += Shader.SizeForType(ShaderTypeForAttr(item));
                }
            }

            int noesisSize = Shader.SizeForFormat(vertexFormat);
            Debug.Assert(offset == noesisSize);            

            return result;
        }

        private static string GetVertexElementFormat(Shader.Vertex.Format.Attr.Type.Enum attributeType)
        {
            switch (attributeType)
            {
                case Shader.Vertex.Format.Attr.Type.Enum.Float:
                    return nameof(VertexElementFormat.Single);

                case Shader.Vertex.Format.Attr.Type.Enum.Float2:
                    return nameof(VertexElementFormat.Vector2);

                case Shader.Vertex.Format.Attr.Type.Enum.Float4:
                    return nameof(VertexElementFormat.Vector4);

                case Shader.Vertex.Format.Attr.Type.Enum.UShort4Norm:
                    return nameof(VertexElementFormat.NormalizedShort4);

                case Shader.Vertex.Format.Attr.Type.Enum.UByte4Norm:
                    return nameof(VertexElementFormat.Color);
            }

            return "Unknown";
        }

        public static Shader.Vertex.Format.Attr.Type.Enum ShaderTypeForAttr(Shader.Vertex.Format.Attr.Enum attr)
        {
            int index = Array.IndexOf(Enum.GetValues(typeof(Shader.Vertex.Format.Attr.Enum)), attr);

            return (Shader.Vertex.Format.Attr.Type.Enum)(new int[8] { 1, 3, 1, 1, 0, 4, 2, 2 })[index];
        }

        private static string GetVertexElementUsage(Shader.Vertex.Format.Attr.Enum attribute)
        {
            switch (attribute)
            {
                case Shader.Vertex.Format.Attr.Enum.Pos:
                    return $"{nameof(VertexElementUsage.Position)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Color:
                    return $"{nameof(VertexElementUsage.Color)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tex0:
                    return $"{nameof(VertexElementUsage.TextureCoordinate)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tex1:
                    return $"{nameof(VertexElementUsage.TextureCoordinate)}, 1";
                case Shader.Vertex.Format.Attr.Enum.Coverage:
                    return $"{nameof(VertexElementUsage.Normal)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Rect:
                    return $"{nameof(VertexElementUsage.Binormal)}, 0";
                case Shader.Vertex.Format.Attr.Enum.Tile:
                    return $"{nameof(VertexElementUsage.Tangent)}, 0";
                case Shader.Vertex.Format.Attr.Enum.ImagePos:
                    return $"{nameof(VertexElementUsage.Normal)}, 1";
                default:
                    return "Unknown";
            }
        }

        public void GenerateVertexUtils(string outputPath)
        {
            using StreamWriter writer = new(System.IO.Path.Combine(outputPath, "NoesisVertexUtils.cs"));

            writer.WriteLine("// <auto-generated/>");
            writer.WriteLine("using Microsoft.Xna.Framework.Graphics;");            
            writer.WriteLine("using System;");
            writer.WriteLine("using System.Collections.Generic;");
            writer.WriteLine("using System.Runtime.InteropServices;");
            writer.WriteLine();
            writer.WriteLine("namespace Noesis.MonoGame.Generated;");
            writer.WriteLine();
            writer.WriteLine("internal class NoesisVertexUtils");
            writer.WriteLine("{");
            writer.WriteLine("    private static List<Action<GraphicsDevice, byte[], short[], Noesis.Batch>> _drawActions = new(new Action<GraphicsDevice, byte[], short[], Noesis.Batch>[]");
            writer.WriteLine("    {");

            for (int i = 0; i < (int)Shader.Enum.Count - 1; i++)
            {
                writer.WriteLine($"        //{(Shader.Enum)i}");
                writer.WriteLine($"        (device, verticesData, indicesData, batch) => DrawUserIndexedPrimitives<NoesisVertex{Shader.FormatForVertex(Shader.VertexForShader((Shader.Enum)i))}>(device, verticesData, indicesData, batch),");
            }

            writer.WriteLine("    });");
            writer.WriteLine();
            writer.WriteLine("    public static void DrawUserIndexedPrimitives(GraphicsDevice device, byte[] verticesData, short[] indicesData, in Noesis.Batch batch)");
            writer.WriteLine("    {");
            writer.WriteLine("        _drawActions[batch.Shader.Index].Invoke(device, verticesData, indicesData, batch);");
            writer.WriteLine("    }");
            writer.WriteLine();
            writer.WriteLine("    public static void DrawUserIndexedPrimitives<T>(GraphicsDevice device, byte[] verticesData, short[] indicesData, in Noesis.Batch batch) where T : struct, IVertexType");
            writer.WriteLine("    {");
            writer.WriteLine("        device.DrawUserIndexedPrimitives(");
            writer.WriteLine("            PrimitiveType.TriangleList,");
            writer.WriteLine("            MemoryMarshal.Cast<byte, T>(verticesData.AsSpan((int)batch.VertexOffset)).ToArray(),");
            writer.WriteLine("            0,");
            writer.WriteLine("            (int)batch.NumVertices,");
            writer.WriteLine("            indicesData,");
            writer.WriteLine("            (int)batch.StartIndex,");
            writer.WriteLine("            (int)batch.NumIndices / 3);");
            writer.WriteLine("    }");
            writer.WriteLine("}");
        }
    }
}
